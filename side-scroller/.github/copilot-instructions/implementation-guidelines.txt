# Implementation Guidelines for Game POC

## Architecture Principles

### Modular Design
- Separate concerns into individual files
- Each file should have a single, clear responsibility
- config.js: Configuration and state variables only
- preload.js: Asset loading and sprite generation only
- create.js: Scene setup and object creation only
- update.js: Game loop and input processing only
- game.js: Game initialization only

### State Management
- Use global variables sparingly (only for game state)
- Initialize all state variables in config.js
- Reset state properly on transitions
- Clean up objects when destroying (set to null)

### Performance Optimization
1. **Cache Everything Possible**
   - Cache keyboard key objects at initialization
   - Reuse sprite objects
   - Avoid creating new objects in update loop
   
2. **Efficient Updates**
   - Early return if conditions not met
   - Use velocity damping instead of setting to 0
   - Minimize calculations per frame

3. **Memory Management**
   - Destroy objects properly before creating new ones
   - Clear arrays after destroying elements
   - Remove event listeners when not needed

## Phaser 3 Best Practices

### Scene Lifecycle
```javascript
function preload() {
    // Load assets
    // Generate sprites
    // No game logic here
}

function create() {
    // Create game objects
    // Setup physics
    // Initialize UI
    // Setup event listeners
    // No update logic here
}

function update() {
    // Process input
    // Update game state
    // Check collisions
    // No object creation here
}
```

### Physics (Matter.js)
```javascript
// Creating physics objects
player = this.matter.add.sprite(x, y, 'spriteKey', frame);
player.setMass(10);
player.setFriction(0.1);
player.setFixedRotation();

// Setting velocity (not force)
player.setVelocity(x, y);
player.setVelocityX(x);
player.setVelocityY(y);

// Damping (smooth stopping)
player.setVelocityX(player.body.velocity.x * 0.9);
```

### Animations
```javascript
// Create animation
scene.anims.create({
    key: 'walk-left',
    frames: scene.anims.generateFrameNumbers('player', { start: 9, end: 16 }),
    frameRate: 10,
    repeat: -1
});

// Play animation
player.anims.play('walk-left', true);

// Check current animation
if (player.anims.currentAnim?.key !== 'walk-left') {
    player.anims.play('walk-left', true);
}
```

### Input Handling
```javascript
// Cache keys at initialization
wasdKeys = {
    W: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.W),
    A: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.A),
    S: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.S),
    D: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.D)
};

// Use in update
const leftPressed = cursors.left.isDown || wasdKeys.A.isDown || moveLeft;
```

## Sprite Generation Guidelines

### Canvas-Based Generation
```javascript
function createSprite(scene, key, width, height, drawFunction) {
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    
    drawFunction(ctx);
    
    scene.textures.addCanvas(key, canvas);
}
```

### Character Sprite Guidelines
- Use simple geometric shapes
- Clear visual hierarchy (head, body, limbs)
- Consistent color palette
- Visible at small sizes (32x48)
- Smooth animations with sine/cosine offsets

### UI Sprite Guidelines
- High contrast for visibility
- Clear icons (simple shapes)
- Consistent sizing (64x64 for buttons)
- Border for definition
- Hover/active states

## Stage Management Guidelines

### Stage Switching
```javascript
function switchToStage(scene, stageNumber) {
    // 1. Update current stage variable
    currentStage = stageNumber;
    
    // 2. Hide all backgrounds
    Object.values(stageBackgrounds).forEach(bg => bg.setVisible(false));
    
    // 3. Show target background
    stageBackgrounds[`bg${stageNumber}`].setVisible(true);
    
    // 4. Destroy old dolls
    destroySquareDolls();
    
    // 5. Create new dolls
    createSquareDollsForStage(scene, stageNumber);
    
    // 6. Position player
    player.setPosition(newX, newY);
    player.setVelocity(0, 0);
}
```

### Edge Detection
```javascript
function checkEdges() {
    if (player.x < -20) {
        // Left edge - show popup
        return 'left';
    } else if (player.x > 820) {
        // Right edge - stage transition
        return 'right';
    }
    return 'none';
}
```

## Physics Implementation Guidelines

### Mass-Based Pushing
- Heavier objects push lighter objects
- Mass ratio: Player (10) / Doll (3) = 3.33x
- Fixed rotation prevents spinning
- Friction affects slide distance

### Top-Down Movement
```javascript
// No gravity
physics: {
    matter: {
        gravity: { y: 0 }
    }
}

// 4-directional velocity
if (upPressed) player.setVelocityY(-speed);
if (downPressed) player.setVelocityY(speed);
if (leftPressed) player.setVelocityX(-speed);
if (rightPressed) player.setVelocityX(speed);

// Damping when no input
if (!anyInputPressed) {
    player.setVelocityX(player.body.velocity.x * 0.9);
    player.setVelocityY(player.body.velocity.y * 0.9);
}
```

## Popup System Guidelines

### Popup Creation
```javascript
function showPopup(scene) {
    // 1. Set popup active flag
    popupActive = true;
    
    // 2. Create overlay
    const overlay = scene.add.rectangle(400, 300, 800, 600, 0x000000, 0.7);
    overlay.setDepth(1000);
    
    // 3. Create background from sprite
    const bg = scene.add.image(400, 300, 'popup-bg');
    bg.setDepth(1001);
    
    // 4. Add text and buttons at higher depths
    // 5. Store all elements for cleanup
    // 6. Setup event handlers
}
```

### Popup Cleanup
```javascript
function closePopup() {
    // 1. Destroy all popup elements
    Object.values(popupOverlay).forEach(el => el.destroy());
    
    // 2. Clear popup reference
    popupOverlay = null;
    
    // 3. Set popup inactive
    popupActive = false;
    
    // 4. Reset game state
    resetGame(scene);
}
```

## Testing Guidelines

### Test Structure
```javascript
describe('Feature Name', () => {
    let state;
    
    beforeEach(() => {
        // Reset state before each test
        state = createInitialState();
    });
    
    test('should do expected behavior', () => {
        // Arrange
        const input = setupInput();
        
        // Act
        const result = performAction(input);
        
        // Assert
        expect(result).toBe(expected);
    });
});
```

### What to Test
1. **Configuration**: Initial values, constants
2. **State Management**: Transitions, resets
3. **Physics**: Mass, collision, movement
4. **Stages**: Transitions, triggers, positions
5. **Animations**: Frame counts, state machine
6. **Input**: Keyboard, touch, combinations
7. **Popup**: Activation, elements, cleanup

### Test Coverage
- Aim for >80% coverage
- Test edge cases
- Test error conditions
- Test state transitions
- Avoid testing Phaser internals

## Mobile Optimization

### Touch Controls
```javascript
// Show only on mobile
if (isMobile) {
    dPad.setVisible(true);
    actionButton.setVisible(true);
}

// Touch event handling
button.on('pointerdown', () => {
    touchState.moveRight = true;
});

button.on('pointerup', () => {
    touchState.moveRight = false;
});
```

### Responsive Scaling
```javascript
scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
    width: 800,
    height: 600
}
```

## Audio Guidelines

### Web Audio API
```javascript
// Initialize
audioContext = new (window.AudioContext || window.webkitAudioContext)();

// Create oscillator
const oscillator = audioContext.createOscillator();
const gainNode = audioContext.createGain();

oscillator.connect(gainNode);
gainNode.connect(audioContext.destination);

oscillator.type = 'sine';
oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);

oscillator.start(audioContext.currentTime);
oscillator.stop(audioContext.currentTime + duration);
```

## Common Pitfalls to Avoid

### ❌ Don't Do This
```javascript
// Creating objects in update loop
function update() {
    const newDoll = this.matter.add.sprite(100, 100, 'doll'); // BAD!
}

// Recreating keys every frame
function update() {
    const keyW = this.input.keyboard.addKey('W'); // BAD!
}

// Not cleaning up objects
function switchStage() {
    createNewDolls(); // BAD! Old dolls still exist
}
```

### ✅ Do This Instead
```javascript
// Create objects in create()
function create() {
    squareDolls = [];
    createSquareDollsForStage(this, 1);
}

// Cache keys
function create() {
    wasdKeys = {
        W: this.input.keyboard.addKey('W')
    };
}

// Proper cleanup
function switchStage() {
    destroySquareDolls(); // Clean up first
    createSquareDollsForStage(scene, stage);
}
```

## Debugging Tips

### Console Logging
```javascript
// Debug player state
console.log('Player:', {
    x: player.x,
    y: player.y,
    vx: player.body.velocity.x,
    vy: player.body.velocity.y,
    stage: currentStage
});
```

### Visual Debugging
```javascript
// Enable Matter.js debug rendering
matter: {
    debug: true  // Shows collision shapes
}
```

### Common Issues
1. **Sprite not showing**: Check depth/layer ordering
2. **Input not working**: Check if popup is blocking
3. **Physics not working**: Check if body exists
4. **Animation not playing**: Check frame indices
5. **Memory leak**: Check for undestroyed objects

## Code Organization

### File Responsibility Matrix

| File | Responsibility | Contains | Doesn't Contain |
|------|---------------|----------|-----------------|
| config.js | State & Config | Variables, constants | Functions, logic |
| preload.js | Asset Loading | Sprite generation | Game logic |
| create.js | Setup | Object creation, UI | Update logic |
| update.js | Game Loop | Input, movement | Object creation |
| game.js | Initialization | Game start | Scene logic |

## Deployment Guidelines

### Production Build
1. Ensure all sprites are generated
2. Test on multiple devices
3. Check performance (60 FPS)
4. Verify no console errors
5. Test all stage transitions
6. Test all input methods
7. Run full test suite

### File Size Optimization
- Phaser minified: ~1.2MB
- Game code: ~20-30KB
- Total: ~1.25MB
- No external assets needed

## Version Control

### Git Workflow
```bash
# Feature branch
git checkout -b feature/new-feature

# Commit with clear messages
git commit -m "Add square doll physics"

# Push and create PR
git push origin feature/new-feature
```

### Commit Message Format
- "Add [feature]" - New functionality
- "Fix [issue]" - Bug fixes
- "Update [component]" - Improvements
- "Remove [unused code]" - Cleanup
- "Refactor [component]" - Code restructure
